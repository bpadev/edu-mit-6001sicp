#lang racket

; 1.2 Procedures and the Processes They Generate
; What we have learned is analogous to that of someone who has learned the rules for how the pieces move in chess but knows...
; ..nothing of typical openings, tactics, or strategy.
; We must learn to visualize the processes generated by various types of procedures.


; 1.2.1 Linear Recursion and Iteration
; Factorial example: n! = n * (n - 1) for any positive integer n
; Linear recursive process grows linearly with n
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
(factorial 9)
; In general, an iterative process is one whose state can be summarized by a fixed number of state variables.
; When we describe a procedure as recursive, we are referring to the syntactic fact that the procedure definition refers to the procedure itself.
; But when we describe a process as following a pattern that is, say linearly recursive, we are speaking about how the process evolves, not about the syntax the procedure is written.
; An iterative process described by a recursive procedure is called tail-recursive.


; 1.2.2 Tree Recursion
; In general, the number of steps required by a tree-recursive process will be proportional to the number of nodes in the tree, while space required will be proportional to the maximum depth of the tree.
; One approach to coping with redundant computations is to arrange matters so that we automatically construct a table of values as they are computed. (tabulation or memoization).

; 1.2.3 Orders of Growth

; 1.2.4 Exponentation

; 1.2.5 Greatest Commond Divisors

; 1.3 Formulating Abstractions with Higher-Order Procedures
; We will be severely limited in our ability to create abstractions if we are restricted to procedures whose parameters must be numbers.
; We will need to construct procedures that can accept procedures as arguments or return procedures as values.
; Procedures that manipulate procedures are called higher-order procedures.

; 1.3.1 Procedures as Arguments
(define (sum-integers a b)
  (if (> a b)
      0
      (+ a (sum-integers (+ a 1)))))

(define (sum-cubes a b)
  (if (> a b)
      0
      (+ (cube a) (sum-cubes (+ a 1) b))))

(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b))))

; 1.3.2 Constructing Procedures Using Lambda
; Using lambda, we can write the integral procedure without having to define the auxiliary procedure add-dx.
; In general lambda is used to create procedures in the same way as define, except that no name is specified for the procedure.

; 1.3.3 Procedures as General Methods
; This section used math exmaples beyond my understanding, the exercises as well. However, I do still understand the power of structuring procedures in a general manner.
; This allows for procedures that have uses across a program, the low specificity allows for reuse in certain places. Another example of modularity and abstraction.

; 1.3.4 Procedures as Returned Values
; This section used the same previous examples, but I already understand the power this functionality brings.
